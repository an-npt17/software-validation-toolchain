(* WP Task for Prover Alt-Ergo,2.6.2 *)
;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(define-fun abs1 ((x Int)) Int
  (ite (<= 0 x) x (- x)))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; "Abs_le"
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "CompatOrderMult"
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< 0 d) (< (mod1 n d) d))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (< (- d) (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< 0 d) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (<= 0 (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= 0 n) (=> (< d 0) (< (mod1 n d) (- d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (< d (mod1 n d)))) :pattern ((mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (=> (<= n 0) (=> (< d 0) (<= (mod1 n d) 0))) :pattern ((mod1 n d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

;; "is_bool"
(define-fun is_bool ((x Int)) Bool
  (or (= x 0) (= x 1)))

;; "is_uint8"
(define-fun is_uint8 ((x Int)) Bool
  (and (<= 0 x) (< x 256)))

;; "is_sint8"
(define-fun is_sint8 ((x Int)) Bool
  (and (<= (- 128) x) (< x 128)))

;; "is_uint16"
(define-fun is_uint16 ((x Int)) Bool
  (and (<= 0 x) (< x 65536)))

;; "is_sint16"
(define-fun is_sint16 ((x Int)) Bool
  (and (<= (- 32768) x) (< x 32768)))

;; "is_uint32"
(define-fun is_uint32 ((x Int)) Bool
  (and (<= 0 x) (< x 4294967296)))

;; "is_sint32"
(define-fun is_sint32 ((x Int)) Bool
  (and (<= (- 2147483648) x) (< x 2147483648)))

;; "is_uint64"
(define-fun is_uint64 ((x Int)) Bool
  (and (<= 0 x) (< x 18446744073709551616)))

;; "is_sint64"
(define-fun is_sint64 ((x Int)) Bool
  (and (<= (- 9223372036854775808) x) (< x 9223372036854775808)))

;; "is_bool0"
(assert (is_bool 0))

;; "is_bool1"
(assert (is_bool 1))

;; "to_uint8"
(declare-fun to_uint8 (Int) Int)

;; "to_uint8'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint8 x) (to_uint8 (+ x 256))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (<= 256 x) (= (to_uint8 x) (to_uint8 (- x 256)))))))

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 256 x)) (= (to_uint8 x) x)))))

;; "to_sint8"
(declare-fun to_sint8 (Int) Int)

;; "to_sint8'def"
(assert
  (forall ((x Int)) (=> (< x (- 128)) (= (to_sint8 x) (to_sint8 (+ x 256))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 128)))
      (=> (<= 128 x) (= (to_sint8 x) (to_sint8 (- x 256)))))))

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 128))) (=> (not (<= 128 x)) (= (to_sint8 x) x)))))

;; "to_uint16"
(declare-fun to_uint16 (Int) Int)

;; "to_uint16'def"
(assert
  (forall ((x Int)) (=> (< x 0) (= (to_uint16 x) (to_uint16 (+ x 65536))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 65536 x) (= (to_uint16 x) (to_uint16 (- x 65536)))))))

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 65536 x)) (= (to_uint16 x) x)))))

;; "to_sint16"
(declare-fun to_sint16 (Int) Int)

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (< x (- 32768)) (= (to_sint16 x) (to_sint16 (+ x 65536))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 32768)))
      (=> (<= 32768 x) (= (to_sint16 x) (to_sint16 (- x 65536)))))))

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (=> (not (< x (- 32768))) (=> (not (<= 32768 x)) (= (to_sint16 x) x)))))

;; "to_uint32"
(declare-fun to_uint32 (Int) Int)

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint32 x) (to_uint32 (+ x 4294967296))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (<= 4294967296 x) (= (to_uint32 x) (to_uint32 (- x 4294967296)))))))

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (=> (not (< x 0)) (=> (not (<= 4294967296 x)) (= (to_uint32 x) x)))))

;; "to_sint32"
(declare-fun to_sint32 (Int) Int)

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=> (< x (- 2147483648)) (= (to_sint32 x) (to_sint32 (+ x 4294967296))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (<= 2147483648 x) (= (to_sint32 x) (to_sint32 (- x 4294967296)))))))

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 2147483648)))
      (=> (not (<= 2147483648 x)) (= (to_sint32 x) x)))))

;; "to_uint64"
(declare-fun to_uint64 (Int) Int)

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=> (< x 0) (= (to_uint64 x) (to_uint64 (+ x 18446744073709551616))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=>
        (<= 18446744073709551616 x)
        (= (to_uint64 x) (to_uint64 (- x 18446744073709551616)))))))

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x 0))
      (=> (not (<= 18446744073709551616 x)) (= (to_uint64 x) x)))))

;; "to_sint64"
(declare-fun to_sint64 (Int) Int)

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (< x (- 9223372036854775808))
      (= (to_sint64 x) (to_sint64 (+ x 18446744073709551616))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=>
        (<= 9223372036854775808 x)
        (= (to_sint64 x) (to_sint64 (- x 18446744073709551616)))))))

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (=>
      (not (< x (- 9223372036854775808)))
      (=> (not (<= 9223372036854775808 x)) (= (to_sint64 x) x)))))

;; "is_to_uint8"
(assert (forall ((x Int)) (is_uint8 (to_uint8 x))))

;; "is_to_sint8"
(assert (forall ((x Int)) (is_sint8 (to_sint8 x))))

;; "is_to_uint16"
(assert (forall ((x Int)) (is_uint16 (to_uint16 x))))

;; "is_to_sint16"
(assert (forall ((x Int)) (is_sint16 (to_sint16 x))))

;; "is_to_uint32"
(assert (forall ((x Int)) (is_uint32 (to_uint32 x))))

;; "is_to_sint32"
(assert (forall ((x Int)) (is_sint32 (to_sint32 x))))

;; "is_to_uint64"
(assert (forall ((x Int)) (is_uint64 (to_uint64 x))))

;; "is_to_sint64"
(assert (forall ((x Int)) (is_sint64 (to_sint64 x))))

;; "id_uint8"
(assert
  (forall ((x Int))
    (! (=> (is_uint8 x) (= (to_uint8 x) x)) :pattern ((to_uint8 x)) )))

;; "id_sint8"
(assert
  (forall ((x Int))
    (! (=> (is_sint8 x) (= (to_sint8 x) x)) :pattern ((to_sint8 x)) )))

;; "id_uint16"
(assert
  (forall ((x Int))
    (! (=> (is_uint16 x) (= (to_uint16 x) x)) :pattern ((to_uint16 x)) )))

;; "id_sint16"
(assert
  (forall ((x Int))
    (! (=> (is_sint16 x) (= (to_sint16 x) x)) :pattern ((to_sint16 x)) )))

;; "id_uint32"
(assert
  (forall ((x Int))
    (! (=> (is_uint32 x) (= (to_uint32 x) x)) :pattern ((to_uint32 x)) )))

;; "id_sint32"
(assert
  (forall ((x Int))
    (! (=> (is_sint32 x) (= (to_sint32 x) x)) :pattern ((to_sint32 x)) )))

;; "id_uint64"
(assert
  (forall ((x Int))
    (! (=> (is_uint64 x) (= (to_uint64 x) x)) :pattern ((to_uint64 x)) )))

;; "id_sint64"
(assert
  (forall ((x Int))
    (! (=> (is_sint64 x) (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "id_uint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 256)) (= (to_uint8 x) x)) :pattern ((to_uint8
                                                                    x)) )))

;; "id_sint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 128) x) (< x 128)) (= (to_sint8 x) x)) :pattern (
    (to_sint8
      x)) )))

;; "id_uint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 65536)) (= (to_uint16 x) x)) :pattern (
    (to_uint16
      x)) )))

;; "id_sint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 32768) x) (< x 32768)) (= (to_sint16 x) x)) :pattern (
    (to_sint16
      x)) )))

;; "id_uint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 4294967296)) (= (to_uint32 x) x)) :pattern (
    (to_uint32
      x)) )))

;; "id_sint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 2147483648) x) (< x 2147483648)) (= (to_sint32 x) x)) :pattern (
    (to_sint32
      x)) )))

;; "id_uint64_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 18446744073709551616)) (= (to_uint64 x) x)) :pattern (
    (to_uint64
      x)) )))

;; "id_sint64_inl"
(assert
  (forall ((x Int))
    (! (=>
         (and (<= (- 9223372036854775808) x) (< x 9223372036854775808))
         (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "proj_int8"
(assert (forall ((x Int)) (= (to_sint8 (to_uint8 x)) (to_sint8 x))))

;; "proj_int16"
(assert (forall ((x Int)) (= (to_sint16 (to_uint16 x)) (to_sint16 x))))

;; "proj_int32"
(assert (forall ((x Int)) (= (to_sint32 (to_uint32 x)) (to_sint32 x))))

;; "proj_int64"
(assert (forall ((x Int)) (= (to_sint64 (to_uint64 x)) (to_sint64 x))))

;; Goal "wp_goal"
(assert
  (not (forall ((i Int)) (=> (<= i 9) (not (is_sint32 i))))))

(check-sat)
