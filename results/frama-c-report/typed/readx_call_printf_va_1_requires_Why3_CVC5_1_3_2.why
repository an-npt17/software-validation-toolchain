(* WP Task for Prover CVC5,1.3.2 *)
;; produced by cvc5.drv ;;
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

;; "sort"
(declare-fun sort (ty
  uni) Bool)

;; "witness"
(declare-fun witness (ty) uni)

;; "witness_sort"
(assert (forall ((a ty)) (sort a (witness a))))

;; "int"
(declare-fun int () ty)

;; "real"
(declare-fun real () ty)

;; "bool"
(declare-fun bool () ty)

;; "infix ->"
(declare-fun infix_mngt (ty
  ty) ty)

(declare-datatypes ((addr 0))
  (((addrqtmk (base Int)(offset Int)))))

;; "addr"
(declare-fun addr1 () ty)

(declare-sort table 0)

;; "table"
(declare-fun table1 () ty)

;; "CompatOrderMult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

;; "abs"
(declare-fun abs1 (Int) Int)

;; "abs'def"
(assert (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

;; "Abs_le"
(assert
  (forall ((x Int) (y Int)) (= (<= (abs1 x) y) (and (<= (- y) x) (<= x y)))))

;; "Abs_pos"
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; "div"
(declare-fun div1 (Int
  Int) Int)

;; "mod"
(declare-fun mod1 (Int
  Int) Int)

;; "Div_mod"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; "Div_bound"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (< 0 y)) (and (<= 0 (div1 x y)) (<= (div1 x y) x)))))

;; "Mod_bound"
(assert
  (forall ((x Int) (y Int))
    (=>
      (not (= y 0))
      (and (< (- (abs1 y)) (mod1 x y)) (< (mod1 x y) (abs1 y))))))

;; "Div_sign_pos"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; "Div_sign_neg"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; "Mod_sign_pos"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; "Mod_sign_neg"
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; "Rounds_toward_zero"
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; "Div_1"
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; "Mod_1"
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; "Div_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; "Mod_inf"
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; "Div_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; "Mod_mult"
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

;; "c_euclidian"
(assert
  (forall ((n Int) (d Int))
    (! (=> (not (= d 0)) (= n (+ (* (div1 n d) d) (mod1 n d)))) :pattern (
    (div1
      n
      d)
    (mod1 n d)) )))

;; "cmod_remainder"
(assert
  (forall ((n Int) (d Int))
    (! (and
         (=> (<= 0 n) (=> (< 0 d) (and (<= 0 (mod1 n d)) (< (mod1 n d) d))))
         (and
           (=>
             (<= n 0)
             (=> (< 0 d) (and (< (- d) (mod1 n d)) (<= (mod1 n d) 0))))
           (and
             (=>
               (<= 0 n)
               (=> (< d 0) (and (<= 0 (mod1 n d)) (< (mod1 n d) (- d)))))
             (=>
               (<= n 0)
               (=> (< d 0) (and (< d (mod1 n d)) (<= (mod1 n d) 0))))))) :pattern (
    (mod1
      n
      d)) )))

;; "cdiv_neutral"
(assert (forall ((a Int)) (! (= (div1 a 1) a) :pattern ((div1 a 1)) )))

;; "cdiv_inv"
(assert
  (forall ((a Int))
    (! (=> (not (= a 0)) (= (div1 a a) 1)) :pattern ((div1 a a)) )))

;; "cdiv_closed_remainder"
(assert
  (forall ((a Int) (b Int) (n Int))
    (=>
      (<= 0 a)
      (=>
        (<= 0 b)
        (=>
          (and (<= 0 (- b a)) (< (- b a) n))
          (=> (= (mod1 a n) (mod1 b n)) (= a b)))))))

;; "infix @"
(declare-fun infix_at (ty
  ty
  uni
  uni) uni)

;; "infix @_sort"
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; "set"
(declare-fun set (ty
  ty
  uni
  uni
  uni) uni)

;; "set_sort"
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni) (x2 uni))
      (sort (infix_mngt a b) (set b a x x1 x2)))))

;; "null"
(declare-fun null () addr)

;; "null'def"
(assert (= null (addrqtmk 0 0)))

;; "global"
(declare-fun global (Int) addr)

;; "global'def"
(assert (forall ((b Int)) (= (global b) (addrqtmk b 0))))

;; "addr_le"
(declare-fun addr_le (addr
  addr) Bool)

;; "addr_lt"
(declare-fun addr_lt (addr
  addr) Bool)

;; "addr_le_bool"
(declare-fun addr_le_bool (addr
  addr) Bool)

;; "addr_lt_bool"
(declare-fun addr_lt_bool (addr
  addr) Bool)

;; "addr_le_def"
(assert
  (forall ((p addr) (q addr))
    (! (=>
         (= (base p) (base q))
         (= (addr_le p q) (<= (offset p) (offset q)))) :pattern ((addr_le
                                                                   p
                                                                   q)) )))

;; "addr_lt_def"
(assert
  (forall ((p addr) (q addr))
    (! (=> (= (base p) (base q)) (= (addr_lt p q) (< (offset p) (offset q)))) :pattern (
    (addr_lt
      p
      q)) )))

;; "addr_le_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (= (addr_le p q) (= (addr_le_bool p q) true)) :pattern ((addr_le_bool
                                                                 p
                                                                 q)) )))

;; "addr_lt_bool_def"
(assert
  (forall ((p addr) (q addr))
    (! (= (addr_lt p q) (= (addr_lt_bool p q) true)) :pattern ((addr_lt_bool
                                                                 p
                                                                 q)) )))

;; "shift"
(declare-fun shift (addr
  Int) addr)

;; "shift'def"
(assert
  (forall ((p addr) (k Int))
    (= (shift p k) (addrqtmk (base p) (+ (offset p) k)))))

;; "valid_rw"
(declare-fun valid_rw ((Array Int Int)
  addr
  Int) Bool)

;; "valid_rw'def"
(assert
  (forall ((m (Array Int Int)) (p addr) (n Int))
    (=
      (valid_rw m p n)
      (=>
        (< 0 n)
        (and
          (< 0 (base p))
          (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))))

;; "valid_rd"
(declare-fun valid_rd ((Array Int Int)
  addr
  Int) Bool)

;; "valid_rd'def"
(assert
  (forall ((m (Array Int Int)) (p addr) (n Int))
    (=
      (valid_rd m p n)
      (=>
        (< 0 n)
        (and
          (not (= 0 (base p)))
          (and (<= 0 (offset p)) (<= (+ (offset p) n) (select m (base p)))))))))

;; "valid_rw_rd"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (forall ((n Int)) (=> (valid_rw m p n) (valid_rd m p n))))))

;; "valid_string"
(assert
  (forall ((m (Array Int Int)))
    (forall ((p addr))
      (=>
        (< (base p) 0)
        (=>
          (and (<= 0 (offset p)) (< (offset p) (select m (base p))))
          (and (valid_rd m p 1) (not (valid_rw m p 1))))))))

;; "included"
(declare-fun included (addr
  Int
  addr
  Int) Bool)

;; "included'def"
(assert
  (forall ((p addr) (lp Int) (q addr) (lq Int))
    (=
      (included p lp q lq)
      (=>
        (< 0 lp)
        (and
          (<= 0 lq)
          (and
            (= (base p) (base q))
            (and
              (<= (offset q) (offset p))
              (<= (+ (offset p) lp) (+ (offset q) lq)))))))))

;; "separated"
(declare-fun separated (addr
  Int
  addr
  Int) Bool)

;; "separated'def"
(assert
  (forall ((p addr) (lp Int) (q addr) (lq Int))
    (=
      (separated p lp q lq)
      (or
        (<= lp 0)
        (or
          (<= lq 0)
          (or
            (not (= (base p) (base q)))
            (or
              (<= (+ (offset q) lq) (offset p))
              (<= (+ (offset p) lp) (offset q)))))))))

;; "separated_1"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int) (i Int) (j Int))
      (! (=>
           (separated p lp q lq)
           (=>
             (and (<= (offset p) i) (< i (+ (offset p) lp)))
             (=>
               (and (<= (offset q) j) (< j (+ (offset q) lq)))
               (not (= (addrqtmk (base p) i) (addrqtmk (base q) j)))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (addrqtmk (base p) i)
      (addrqtmk (base q) j)) ))))

;; "separated_included"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (=>
           (< 0 lp)
           (=>
             (< 0 lq)
             (=> (separated p lp q lq) (not (included p lp q lq))))) :pattern (
      (separated
        p
        lp
        q
        lq)
      (included p lp q lq)) ))))

;; "included_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (included q lq r lr) (included p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (included q lq r lr)) ))))

;; "separated_trans"
(assert
  (forall ((p addr) (q addr) (r addr))
    (forall ((lp Int) (lq Int) (lr Int))
      (! (=>
           (included p lp q lq)
           (=> (separated q lq r lr) (separated p lp r lr))) :pattern (
      (included
        p
        lp
        q
        lq)
      (separated q lq r lr)) ))))

;; "separated_sym"
(assert
  (forall ((p addr) (q addr))
    (forall ((lp Int) (lq Int))
      (! (= (separated p lp q lq) (separated q lq p lp)) :pattern ((separated
                                                                    p
                                                                    lp
                                                                    q
                                                                    lq)) ))))

;; "region"
(declare-fun region (Int) Int)

;; "linked"
(declare-fun linked ((Array Int Int)) Bool)

;; "static_malloc"
(declare-fun static_malloc (Int) Int)

;; "statically_allocated"
(declare-fun statically_allocated (Int) Bool)

;; "statically_allocated'def"
(assert
  (forall ((base1 Int))
    (=
      (statically_allocated base1)
      (or (= base1 0) (< 0 (static_malloc base1))))))

;; "valid_pointers_are_statically_allocated"
(assert
  (forall ((a addr) (m (Array Int Int)) (n Int))
    (=> (< 0 n) (=> (valid_rd m a n) (statically_allocated (base a))))))

;; "int_of_addr"
(declare-fun int_of_addr (addr) Int)

;; "addr_of_int"
(declare-fun addr_of_int (Int) addr)

;; "addr_of_null"
(assert (= (int_of_addr null) 0))

;; "addr_of_int_bijection"
(assert
  (forall ((p addr))
    (=> (statically_allocated (base p)) (= (addr_of_int (int_of_addr p)) p))))

;; "table_to_offset"
(declare-fun table_to_offset (table
  Int) Int)

;; "table_to_offset_zero"
(assert (forall ((t table)) (= (table_to_offset t 0) 0)))

;; "table_to_offset_monotonic"
(assert
  (forall ((t table))
    (forall ((o1 Int) (o2 Int))
      (= (<= o1 o2) (<= (table_to_offset t o1) (table_to_offset t o2))))))

;; "is_bool"
(declare-fun is_bool (Int) Bool)

;; "is_bool'def"
(assert (forall ((x Int)) (= (is_bool x) (or (= x 0) (= x 1)))))

;; "is_uint8"
(declare-fun is_uint8 (Int) Bool)

;; "is_uint8'def"
(assert (forall ((x Int)) (= (is_uint8 x) (and (<= 0 x) (< x 256)))))

;; "is_sint8"
(declare-fun is_sint8 (Int) Bool)

;; "is_sint8'def"
(assert (forall ((x Int)) (= (is_sint8 x) (and (<= (- 128) x) (< x 128)))))

;; "is_uint16"
(declare-fun is_uint16 (Int) Bool)

;; "is_uint16'def"
(assert (forall ((x Int)) (= (is_uint16 x) (and (<= 0 x) (< x 65536)))))

;; "is_sint16"
(declare-fun is_sint16 (Int) Bool)

;; "is_sint16'def"
(assert
  (forall ((x Int)) (= (is_sint16 x) (and (<= (- 32768) x) (< x 32768)))))

;; "is_uint32"
(declare-fun is_uint32 (Int) Bool)

;; "is_uint32'def"
(assert (forall ((x Int)) (= (is_uint32 x) (and (<= 0 x) (< x 4294967296)))))

;; "is_sint32"
(declare-fun is_sint32 (Int) Bool)

;; "is_sint32'def"
(assert
  (forall ((x Int))
    (= (is_sint32 x) (and (<= (- 2147483648) x) (< x 2147483648)))))

;; "is_uint64"
(declare-fun is_uint64 (Int) Bool)

;; "is_uint64'def"
(assert
  (forall ((x Int))
    (= (is_uint64 x) (and (<= 0 x) (< x 18446744073709551616)))))

;; "is_sint64"
(declare-fun is_sint64 (Int) Bool)

;; "is_sint64'def"
(assert
  (forall ((x Int))
    (=
      (is_sint64 x)
      (and (<= (- 9223372036854775808) x) (< x 9223372036854775808)))))

;; "is_bool0"
(assert (is_bool 0))

;; "is_bool1"
(assert (is_bool 1))

;; "to_uint8"
(declare-fun to_uint8 (Int) Int)

;; "to_uint8'def"
(assert
  (forall ((x Int))
    (ite (< x 0)
      (= (to_uint8 x) (to_uint8 (+ x 256)))
      (ite (<= 256 x)
        (= (to_uint8 x) (to_uint8 (- x 256)))
        (= (to_uint8 x) x)))))

;; "to_sint8"
(declare-fun to_sint8 (Int) Int)

;; "to_sint8'def"
(assert
  (forall ((x Int))
    (ite (< x (- 128))
      (= (to_sint8 x) (to_sint8 (+ x 256)))
      (ite (<= 128 x)
        (= (to_sint8 x) (to_sint8 (- x 256)))
        (= (to_sint8 x) x)))))

;; "to_uint16"
(declare-fun to_uint16 (Int) Int)

;; "to_uint16'def"
(assert
  (forall ((x Int))
    (ite (< x 0)
      (= (to_uint16 x) (to_uint16 (+ x 65536)))
      (ite (<= 65536 x)
        (= (to_uint16 x) (to_uint16 (- x 65536)))
        (= (to_uint16 x) x)))))

;; "to_sint16"
(declare-fun to_sint16 (Int) Int)

;; "to_sint16'def"
(assert
  (forall ((x Int))
    (ite (< x (- 32768))
      (= (to_sint16 x) (to_sint16 (+ x 65536)))
      (ite (<= 32768 x)
        (= (to_sint16 x) (to_sint16 (- x 65536)))
        (= (to_sint16 x) x)))))

;; "to_uint32"
(declare-fun to_uint32 (Int) Int)

;; "to_uint32'def"
(assert
  (forall ((x Int))
    (ite (< x 0)
      (= (to_uint32 x) (to_uint32 (+ x 4294967296)))
      (ite (<= 4294967296 x)
        (= (to_uint32 x) (to_uint32 (- x 4294967296)))
        (= (to_uint32 x) x)))))

;; "to_sint32"
(declare-fun to_sint32 (Int) Int)

;; "to_sint32'def"
(assert
  (forall ((x Int))
    (ite (< x (- 2147483648))
      (= (to_sint32 x) (to_sint32 (+ x 4294967296)))
      (ite (<= 2147483648 x)
        (= (to_sint32 x) (to_sint32 (- x 4294967296)))
        (= (to_sint32 x) x)))))

;; "to_uint64"
(declare-fun to_uint64 (Int) Int)

;; "to_uint64'def"
(assert
  (forall ((x Int))
    (ite (< x 0)
      (= (to_uint64 x) (to_uint64 (+ x 18446744073709551616)))
      (ite (<= 18446744073709551616 x)
        (= (to_uint64 x) (to_uint64 (- x 18446744073709551616)))
        (= (to_uint64 x) x)))))

;; "to_sint64"
(declare-fun to_sint64 (Int) Int)

;; "to_sint64'def"
(assert
  (forall ((x Int))
    (ite (< x (- 9223372036854775808))
      (= (to_sint64 x) (to_sint64 (+ x 18446744073709551616)))
      (ite (<= 9223372036854775808 x)
        (= (to_sint64 x) (to_sint64 (- x 18446744073709551616)))
        (= (to_sint64 x) x)))))

;; "is_to_uint8"
(assert (forall ((x Int)) (is_uint8 (to_uint8 x))))

;; "is_to_sint8"
(assert (forall ((x Int)) (is_sint8 (to_sint8 x))))

;; "is_to_uint16"
(assert (forall ((x Int)) (is_uint16 (to_uint16 x))))

;; "is_to_sint16"
(assert (forall ((x Int)) (is_sint16 (to_sint16 x))))

;; "is_to_uint32"
(assert (forall ((x Int)) (is_uint32 (to_uint32 x))))

;; "is_to_sint32"
(assert (forall ((x Int)) (is_sint32 (to_sint32 x))))

;; "is_to_uint64"
(assert (forall ((x Int)) (is_uint64 (to_uint64 x))))

;; "is_to_sint64"
(assert (forall ((x Int)) (is_sint64 (to_sint64 x))))

;; "id_uint8"
(assert
  (forall ((x Int))
    (! (=> (is_uint8 x) (= (to_uint8 x) x)) :pattern ((to_uint8 x)) )))

;; "id_sint8"
(assert
  (forall ((x Int))
    (! (=> (is_sint8 x) (= (to_sint8 x) x)) :pattern ((to_sint8 x)) )))

;; "id_uint16"
(assert
  (forall ((x Int))
    (! (=> (is_uint16 x) (= (to_uint16 x) x)) :pattern ((to_uint16 x)) )))

;; "id_sint16"
(assert
  (forall ((x Int))
    (! (=> (is_sint16 x) (= (to_sint16 x) x)) :pattern ((to_sint16 x)) )))

;; "id_uint32"
(assert
  (forall ((x Int))
    (! (=> (is_uint32 x) (= (to_uint32 x) x)) :pattern ((to_uint32 x)) )))

;; "id_sint32"
(assert
  (forall ((x Int))
    (! (=> (is_sint32 x) (= (to_sint32 x) x)) :pattern ((to_sint32 x)) )))

;; "id_uint64"
(assert
  (forall ((x Int))
    (! (=> (is_uint64 x) (= (to_uint64 x) x)) :pattern ((to_uint64 x)) )))

;; "id_sint64"
(assert
  (forall ((x Int))
    (! (=> (is_sint64 x) (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "id_uint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 256)) (= (to_uint8 x) x)) :pattern ((to_uint8
                                                                    x)) )))

;; "id_sint8_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 128) x) (< x 128)) (= (to_sint8 x) x)) :pattern (
    (to_sint8
      x)) )))

;; "id_uint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 65536)) (= (to_uint16 x) x)) :pattern (
    (to_uint16
      x)) )))

;; "id_sint16_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 32768) x) (< x 32768)) (= (to_sint16 x) x)) :pattern (
    (to_sint16
      x)) )))

;; "id_uint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 4294967296)) (= (to_uint32 x) x)) :pattern (
    (to_uint32
      x)) )))

;; "id_sint32_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= (- 2147483648) x) (< x 2147483648)) (= (to_sint32 x) x)) :pattern (
    (to_sint32
      x)) )))

;; "id_uint64_inl"
(assert
  (forall ((x Int))
    (! (=> (and (<= 0 x) (< x 18446744073709551616)) (= (to_uint64 x) x)) :pattern (
    (to_uint64
      x)) )))

;; "id_sint64_inl"
(assert
  (forall ((x Int))
    (! (=>
         (and (<= (- 9223372036854775808) x) (< x 9223372036854775808))
         (= (to_sint64 x) x)) :pattern ((to_sint64 x)) )))

;; "proj_int8"
(assert (forall ((x Int)) (= (to_sint8 (to_uint8 x)) (to_sint8 x))))

;; "proj_int16"
(assert (forall ((x Int)) (= (to_sint16 (to_uint16 x)) (to_sint16 x))))

;; "proj_int32"
(assert (forall ((x Int)) (= (to_sint32 (to_uint32 x)) (to_sint32 x))))

;; "proj_int64"
(assert (forall ((x Int)) (= (to_sint64 (to_uint64 x)) (to_sint64 x))))

;; "is_sint8_chunk"
(declare-fun is_sint8_chunk ((Array addr Int)) Bool)

;; "is_sint8_chunk'def"
(assert
  (forall ((m (Array addr Int)))
    (= (is_sint8_chunk m) (forall ((a addr)) (is_sint8 (select m a))))))

;; "sconst"
(declare-fun sconst ((Array addr Int)) Bool)

;; "eqmem"
(declare-fun eqmem (ty
  uni
  uni
  addr
  Int) Bool)

;; "t2tb"
(declare-fun t2tb ((Array addr Int)) uni)

;; "t2tb_sort"
(assert
  (forall ((x (Array addr Int))) (sort (infix_mngt addr1 int) (t2tb x))))

;; "tb2t"
(declare-fun tb2t (uni) (Array addr Int))

;; "BridgeL"
(assert
  (forall ((i (Array addr Int)))
    (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; "BridgeR"
(assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; "eqmem'def"
(assert
  (forall ((m1 (Array addr Int)) (m2 (Array addr Int)) (p addr) (n Int))
    (=
      (eqmem int (t2tb m1) (t2tb m2) p n)
      (forall ((q addr))
        (! (=> (included q 1 p n) (= (select m1 q) (select m2 q))) :pattern ((select m1 q)) :pattern ((select m2 q)) )))))

;; "t2tb"
(declare-fun t2tb1 (addr) uni)

;; "t2tb_sort"
(assert (forall ((x addr)) (sort addr1 (t2tb1 x))))

;; "tb2t"
(declare-fun tb2t1 (uni) addr)

;; "BridgeL"
(assert
  (forall ((i addr)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; "BridgeR"
(assert
  (forall ((j uni))
    (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; "eqmem'def"
(assert
  (forall ((a ty))
    (forall ((m1 uni) (m2 uni) (p addr) (n Int))
      (=
        (eqmem a m1 m2 p n)
        (forall ((q addr))
          (! (=>
               (included q 1 p n)
               (= (infix_at a addr1 m1 (t2tb1 q)) (infix_at
                                                    a
                                                    addr1
                                                    m2
                                                    (t2tb1 q)))) :pattern (
          (infix_at
            a
            addr1
            m1
            (t2tb1 q))) :pattern ((infix_at a addr1 m2 (t2tb1 q))) ))))))

;; "memcpy"
(declare-fun memcpy (ty
  uni
  addr
  uni
  addr
  Int) uni)

;; "memcpy_sort"
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 addr) (x2 uni) (x3 addr) (x4 Int))
      (sort (infix_mngt addr1 a) (memcpy a x x1 x2 x3 x4)))))

;; "memcpy'def"
(assert
  (forall ((m0 (Array addr Int)) (a0 addr) (m1 (Array addr Int)) (a1 addr) (s Int))
    (forall ((p addr))
      (= (select (tb2t (memcpy int (t2tb m0) a0 (t2tb m1) a1 s)) p) (ite 
                                                                    (separated
                                                                    p
                                                                    1
                                                                    a0
                                                                    s)
                                                                    (select m0 p)
                                                                    (let ((offset1 (+ (- 
                                                                    (offset
                                                                    a1) 
                                                                    (offset
                                                                    a0)) 
                                                                    (offset
                                                                    p))))
                                                                    (select m1 
                                                                    (addrqtmk
                                                                    (base a1)
                                                                    offset1))))))))

;; "memcpy'def"
(assert
  (forall ((a ty))
    (forall ((m0 uni) (a0 addr) (m1 uni) (a1 addr) (s Int))
      (forall ((p addr))
        (= (infix_at a addr1 (memcpy a m0 a0 m1 a1 s) (t2tb1 p)) (ite 
                                                                   (separated
                                                                    p
                                                                    1
                                                                    a0
                                                                    s)
                                                                   (infix_at
                                                                    a
                                                                    addr1
                                                                    m0
                                                                    (t2tb1 p))
                                                                   (let ((offset1 (+ (- 
                                                                    (offset
                                                                    a1) 
                                                                    (offset
                                                                    a0)) 
                                                                    (offset
                                                                    p))))
                                                                    (infix_at
                                                                    a
                                                                    addr1
                                                                    m1
                                                                    (t2tb1
                                                                    (addrqtmk
                                                                    (base a1)
                                                                    offset1))))))))))

;; "eqmem_single"
(assert
  (forall ((m1 (Array addr Int)) (m2 (Array addr Int)))
    (forall ((p addr))
      (= (eqmem int (t2tb m1) (t2tb m2) p 1) (= (select m1 p) (select m2 p))))))

;; "eqmem_single"
(assert
  (forall ((a ty))
    (forall ((m1 uni) (m2 uni))
      (forall ((p addr))
        (=
          (eqmem a m1 m2 p 1)
          (= (infix_at a addr1 m1 (t2tb1 p)) (infix_at a addr1 m2 (t2tb1 p))))))))

;; "eqmem_included"
(assert
  (forall ((a ty))
    (forall ((m1 uni) (m2 uni))
      (forall ((p addr) (q addr))
        (forall ((a1 Int) (b Int))
          (! (=>
               (included p a1 q b)
               (=> (eqmem a m1 m2 q b) (eqmem a m1 m2 p a1))) :pattern (
          (eqmem
            a
            m1
            m2
            p
            a1)
          (eqmem a m1 m2 q b)) ))))))

;; "eqmem_sym"
(assert
  (forall ((a ty))
    (forall ((m1 uni) (m2 uni))
      (forall ((p addr))
        (forall ((a1 Int)) (=> (eqmem a m1 m2 p a1) (eqmem a m2 m1 p a1)))))))

;; "eqmem_update"
(assert
  (forall ((m0 (Array addr Int)))
    (forall ((v Int))
      (forall ((p addr) (q addr))
        (forall ((nqt Int))
          (=>
            (separated p 1 q nqt)
            (eqmem int (t2tb m0) (t2tb (store m0 p v)) q nqt)))))))

;; "eqmem_update"
(assert
  (forall ((a ty))
    (forall ((m0 uni))
      (forall ((v uni))
        (forall ((p addr) (q addr))
          (forall ((nqt Int))
            (=>
              (separated p 1 q nqt)
              (eqmem a m0 (set a addr1 m0 (t2tb1 p) v) q nqt))))))))

;; "eqmem_memcpy"
(assert
  (forall ((a ty))
    (forall ((m0 uni) (m1 uni))
      (forall ((p addr) (pqt addr) (q addr))
        (forall ((n Int) (nqt Int))
          (=>
            (separated p n pqt nqt)
            (eqmem a m0 (memcpy a m0 p m1 q n) pqt nqt)))))))

;; "L_strlen"
(declare-fun L_strlen ((Array addr Int)
  addr) Int)

;; "Q_strlen_pos_or_null"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (=>
        (= x 0)
        (=>
          (<= 0 i)
          (=>
            (is_sint8_chunk Mchar)
            (=>
              (is_sint8 x)
              (=>
                (forall ((i1 Int))
                  (=>
                    (<= 0 i1)
                    (=> (< i1 i) (not (= (select Mchar (shift s i1)) 0)))))
                (= (L_strlen Mchar s) i)))))))))

;; "Q_strlen_neg"
(assert
  (forall ((Mchar (Array addr Int)) (s addr))
    (=>
      (is_sint8_chunk Mchar)
      (=>
        (forall ((i Int))
          (=> (<= 0 i) (not (= (select Mchar (shift s i)) 0))))
        (< (L_strlen Mchar s) 0)))))

;; "Q_strlen_before_null"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (=>
        (<= 0 i)
        (=>
          (< i (L_strlen Mchar s))
          (=> (is_sint8_chunk Mchar) (=> (is_sint8 x) (not (= x 0)))))))))

;; "Q_strlen_at_null"
(assert
  (forall ((Mchar (Array addr Int)) (s addr))
    (let ((x (L_strlen Mchar s)))
      (let ((x1 (select Mchar (shift s x))))
        (=> (<= 0 x) (=> (is_sint8_chunk Mchar) (=> (is_sint8 x1) (= x1 0))))))))

;; "Q_strlen_not_zero"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (let ((x1 (L_strlen Mchar s)))
        (=>
          (not (= x 0))
          (=>
            (<= 0 i)
            (=>
              (<= i x1)
              (=> (is_sint8_chunk Mchar) (=> (is_sint8 x) (< i x1))))))))))

;; "Q_strlen_zero"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (let ((x1 (L_strlen Mchar s)))
        (=>
          (= x 0)
          (=>
            (<= 0 i)
            (=>
              (<= i x1)
              (=> (is_sint8_chunk Mchar) (=> (is_sint8 x) (= x1 i))))))))))

;; "Q_strlen_sup"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (let ((x1 (L_strlen Mchar s)))
        (=>
          (= x 0)
          (=>
            (<= 0 i)
            (=>
              (is_sint8_chunk Mchar)
              (=> (is_sint8 x) (and (<= x1 i) (<= 0 x1))))))))))

;; "Q_strlen_shift"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (L_strlen Mchar s)))
      (=>
        (<= 0 i)
        (=>
          (<= i x)
          (=>
            (is_sint8_chunk Mchar)
            (= (+ i (L_strlen Mchar (shift s i))) x)))))))

;; "Q_strlen_create"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int))
    (let ((x (select Mchar (shift s i))))
      (let ((x1 (L_strlen Mchar s)))
        (=>
          (= x 0)
          (=>
            (<= 0 i)
            (=>
              (is_sint8_chunk Mchar)
              (=> (is_sint8 x) (and (<= x1 i) (<= 0 x1))))))))))

;; "Q_strlen_create_shift"
(assert
  (forall ((Mchar (Array addr Int)) (s addr) (i Int) (k Int))
    (let ((x (select Mchar (shift s i))))
      (let ((x1 (L_strlen Mchar (shift s k))))
        (=>
          (= x 0)
          (=>
            (<= k i)
            (=>
              (<= 0 k)
              (=>
                (is_sint8_chunk Mchar)
                (=> (is_sint8 x) (and (<= 0 x1) (<= (+ k x1) i)))))))))))

;; "L_memcmp"
(declare-fun L_memcmp ((Array addr Int)
  (Array addr Int)
  addr
  addr
  Int) Int)

;; "Q_memcmp_zero"
(assert
  (forall ((Mchar (Array addr Int)) (Mchar1 (Array addr Int)) (s1 addr) (s2 addr) (n Int))
    (=>
      (is_sint8_chunk Mchar)
      (=>
        (is_sint8_chunk Mchar1)
        (=
          (forall ((i Int))
            (=>
              (<= 0 i)
              (=>
                (< i n)
                (= (select Mchar1 (shift s1 i)) (select Mchar (shift s2 i))))))
          (= (L_memcmp Mchar Mchar1 s1 s2 n) 0))))))

;; "Q_memcmp_strlen_left"
(assert
  (forall ((Mchar (Array addr Int)) (s1 addr) (s2 addr) (n Int))
    (let ((x (L_strlen Mchar s1)))
      (=>
        (= (L_memcmp Mchar Mchar s1 s2 n) 0)
        (=> (< x n) (=> (is_sint8_chunk Mchar) (= (L_strlen Mchar s2) x)))))))

;; "Q_memcmp_strlen_right"
(assert
  (forall ((Mchar (Array addr Int)) (s1 addr) (s2 addr) (n Int))
    (let ((x (L_strlen Mchar s2)))
      (=>
        (= (L_memcmp Mchar Mchar s1 s2 n) 0)
        (=> (< x n) (=> (is_sint8_chunk Mchar) (= x (L_strlen Mchar s1))))))))

;; "Q_memcmp_strlen_shift_left"
(assert
  (forall ((Mchar (Array addr Int)) (s1 addr) (s2 addr) (k Int) (n Int))
    (let ((x (L_strlen Mchar s1)))
      (let ((x1 (L_strlen Mchar s2)))
        (=>
          (= (L_memcmp Mchar Mchar s1 (shift s2 k) n) 0)
          (=>
            (<= 0 k)
            (=>
              (< x n)
              (=> (is_sint8_chunk Mchar) (and (<= 0 x1) (<= x1 (+ k x)))))))))))

;; "Q_memcmp_strlen_shift_right"
(assert
  (forall ((Mchar (Array addr Int)) (s1 addr) (s2 addr) (k Int) (n Int))
    (let ((x (L_strlen Mchar s2)))
      (let ((x1 (L_strlen Mchar s1)))
        (=>
          (= (L_memcmp Mchar Mchar (shift s1 k) s2 n) 0)
          (=>
            (<= 0 k)
            (=>
              (< x n)
              (=> (is_sint8_chunk Mchar) (and (<= 0 x1) (<= x1 (+ k x)))))))))))

;; "P_valid_read_string"
(declare-fun P_valid_read_string ((Array Int Int)
  (Array addr Int)
  addr) Bool)

;; "P_valid_read_string'def"
(assert
  (forall ((Malloc (Array Int Int)) (Mchar (Array addr Int)) (s addr))
    (let ((x (L_strlen Mchar s)))
      (=
        (P_valid_read_string Malloc Mchar s)
        (and (<= 0 x) (valid_rd Malloc (shift s 0) (+ 1 x)))))))

;; "Str_1"
(declare-fun Str_1 () Int)

;; "Lit_C700"
(declare-fun Lit_C700 () (Array Int Int))

;; "Q_Str_1_base"
(assert (< Str_1 0))

;; "Q_Str_1_region"
(assert (= (region Str_1) (- 50944)))

;; "Q_Str_1_linked"
(assert
  (forall ((t (Array Int Int))) (=> (linked t) (= (select t Str_1) 19))))

;; "Q_Str_1_literal"
(assert
  (forall ((mchar (Array addr Int)) (i Int))
    (=>
      (sconst mchar)
      (= (select mchar (shift (global Str_1) i)) (select Lit_C700 i)))))

;; Goal "wp_goal"
(assert
  (not
  (forall ((t (Array Int Int)) (t1 (Array addr Int)))
    (=>
      (is_sint8_chunk t1)
      (=>
        (linked t)
        (=> (sconst t1) (P_valid_read_string t t1 (shift (global Str_1) 0))))))))

(check-sat)
(get-info :reason-unknown)
