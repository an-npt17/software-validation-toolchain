\chapter{System Architecture}

\section{Overview}

The toolchain implements a five-level verification pipeline:

\begin{enumerate}
	\item \textbf{Level 1 - Natural Language Requirements}: User stories and plain English specifications
	\item \textbf{Level 2 - Formal Logic \& Models}: LTL formulas, UML diagrams, behavioral models
	\item \textbf{Level 3 - Formal Specifications}: ACSL contracts, assertions, invariants
	\item \textbf{Level 4 - Static Verification}: Deductive verification, model checking, SMT solving
	\item \textbf{Level 5 - Dynamic Testing}: Symbolic execution, fuzzing, memory analysis
\end{enumerate}

% Note: Include architecture diagram here
% \begin{figure}[htbp]
% \centerline{\includegraphics[width=\columnwidth]{figures/architecture.pdf}}
% \caption{Five-level verification pipeline architecture}
% \label{fig:architecture}
% \end{figure}

\section{AI-Powered Translation Layer}

The cornerstone of the toolchain is the AI translation layer powered by Google Gemini 2.5 Flash. This component:

\begin{itemize}
	\item Accepts natural language requirements as input
	\item Uses prompt engineering with ACSL/LTL examples
	\item Generates structured JSON output with confidence scores
	\item Supports context-aware generation (function names, variable types)
\end{itemize}

We chose Gemini 2.5 Flash for its:
\begin{itemize}
	\item Fast inference (low latency)
	\item Strong code understanding capabilities
	\item Reliable structured output generation
	\item Generous free tier (60 requests/minute)
\end{itemize}

\section{Verification Tools Integration}

\subsection{Static Verification}

\textbf{Frama-C with WP Plugin}: Performs deductive verification by generating verification conditions (VCs) and proving them using SMT solvers (Z3, CVC5, Alt-Ergo).

\textbf{Why3}: Serves as a multi-prover platform, allowing verification conditions to be checked by multiple SMT solvers simultaneously.

\textbf{CBMC}: Performs bounded model checking by unwinding loops and encoding the program as an SMT formula.

\subsection{Dynamic Testing}

\textbf{KLEE}: Symbolically executes programs to explore all possible execution paths within resource bounds, generating concrete test cases for each path.

\textbf{AFL++}: Performs coverage-guided fuzzing, mutating inputs to discover crashes and assertion violations.

\textbf{Valgrind}: Detects memory errors, leaks, and thread synchronization issues through dynamic binary instrumentation.

\section{Reproducible Environment}

The toolchain uses Nix package manager to ensure reproducibility:

\begin{itemize}
	\item Declarative specification of all dependencies in \texttt{flake.nix}
	\item Version-locked packages with cryptographic hashes
	\item Isolated development environments
	\item Cross-platform support (Linux, macOS)
\end{itemize}
